# -*- coding: utf-8 -*-
"""nlp_assignment3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VIWPR-douwB8lcNJrMtsVB8655XjaagO
"""

import numpy as np
import pandas as pd
import random
import re

from google.colab import drive
drive.mount('/content/drive')

cd '/content/drive/My Drive/Colab Notebooks'

class CYK(object):
  def __init__(self):
    self.rulesDict = {}
    return
   
  # It takes folder path as a argument and return rules set 
  def rules(self, folderPath):
    global wordsList
    # Read all sentences
    with open(folderPath) as f:
      linesList = f.read().splitlines() 

    # Create list and dict for words and rules
    rulesDict = {}
    wordsList = []
    for i in linesList:
      # if there is a comment after rule, delete
      if len(i.strip()) != 0 and not i.startswith('#'):
        if '#' in i:
          i = ''.join(i.split('#')[0])
        # Split line into two pieces, first piece is Terminal
        words = i.split('\t')
        if not words[0].strip() in rulesDict.keys():
          rulesDict[words[0].strip()] = []

        rulesDict[words[0].strip()].append(words[1].split())
        
        # If piece is lowercase then its word
        if words[1].split()[0].islower():
          wordsList.append(words[1].split()[0])
    self.rulesDict = rulesDict
    return rulesDict

  # It is for randsentence, it takes start terminal end list then it generates random rule's word
  def recursFunc(self, start, expansion):
    if start in self.rulesDict.keys():
      pick = random.choice(self.rulesDict[start])
      for i in range(len(pick)):
        self.recursFunc(pick[i], expansion)
    else:
      expansion.append(start)

  # It takes rules, and define start terminal, then call recursive function
  def randsentence(self, rulesDict): 
    wordList = []
    start = 'S'
    self.recursFunc(start, wordList)
    generatedSentence = ' '.join(wordList)
    return generatedSentence

  # It takes rules and integer then it generate random words from word list.
  def randsentence2(self, rulesDict, n):
    words = []
    for i in range(n):
      words.append(random.choice(wordsList))
    
    return ' '.join(words)

  # It get value and return corresponding key in rules set
  def get_key(self, val): 
    keys = ''
    for key, values in self.rulesDict.items(): 
      for value in values:
        if val == value: 
          keys += key + ' ' 
    if not keys is '':
      return keys.strip()
    else:
      return ''

  def comp(self, first, second):
    # Find key
    matchKey = self.get_key([first[0], second[0]])
    # If key is not found, search value's another key
    if matchKey is '':
      firstList = [first[0], self.get_key([first[0]])]
      secondList = [second[0], self.get_key([second[0]])]
      keys = ''
      for el1 in firstList:
        for el2 in secondList:
          key = self.get_key([el1, el2])
          if not key in keys:
            keys += key + ' '
      return keys.strip()              
      
    return matchKey
  
  def defuse(self, i, j):
    newKeys = ''
    for x in range(i, j):
      a = Matris[i][x]
      b = Matris[x+1][j]
      res = self.comp(a,b)
      if not res in newKeys:
        newKeys += res + ' '
    if newKeys.strip() is '':
      newKeys = '-'
    return newKeys.strip()

  def CYKParser(self, sentence):
    global Matris
    # Create dict for CYK Parser
    Matris = {}

    words = sentence.split()
    # First 'for loop' for initial state X(i,i) 
    for i in range(len(words)):
      Matris[i + 1] = {}
      Matris[i + 1][i + 1] = []
      keys = self.get_key([words[i]])
      
      if keys is '':
        keys = '-'
      Matris[i + 1][i + 1].append(keys)


    for i in range(1, len(words)):
      for j in range(1, len(words) - i + 1):
        Matris[j][j + i] = []
        listt = self.defuse(j, j + i)
        Matris[j][j + i].append(listt)

    if Matris[1][len(words)][0] is 'S':
      return 'Correct'
    else: 
      return 'Not Correct'

  def Test(self):
    recursFunc('-', [])
    get_key(['-'])
    comp([],[])
    defuse(0,0)

cyk = CYK()

rulesSet = cyk.rules('cfg.gr')

grammaticallyCorrectSentence = cyk.randsentence(rulesSet)
grammaticallyNotCorrectSentence = cyk.randsentence2(rulesSet, 10)

state1 = cyk.CYKParser(grammaticallyCorrectSentence)
state2 = cyk.CYKParser(grammaticallyNotCorrectSentence)

print(grammaticallyCorrectSentence)
print(state1)
print()
print(grammaticallyNotCorrectSentence)
print(state2)

# This part generate correct sentence with randsentence2 function, which is contain all random words
a = True
sent =''
while a:
  sent = cyk.randsentence2(rulesSet, 6)
  cor = cyk.CYKParser(sent)
  if cor is 'Correct':
    print(sent)
    a = False